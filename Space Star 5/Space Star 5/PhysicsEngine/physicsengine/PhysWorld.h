/*****************************************************************************************
*                                                                                        *
*  Program Name:          PhysWorld.h                                                    *
*  Name:                  Jennifer Wickensimer                                           *
*  Date:                  January 23, 2012                                               *
*  Description:           World class include file                                       *
*                                                                                        *
*  Update:                Jennifer Wickensimer, 01/28/2012                               *
*                                                                                        *
*****************************************************************************************/


#ifndef PHYSICSENGINE_PHYSWORLD_H_
#define PHYSICSENGINE_PHYSWORLD_H_

#include "PhysBody.h"
#include "ContactResolution.h"


namespace PhysicsEngine
{


class World
{

	// bool to tell whether the world should calculat the number of interation 

	bool b_mCalculateInterations;

	
	//The below holds a single PhysBody in a linked list of bodies

	struct BodyRegistration
	{
		PhysBody *body;
		BodyRegistration * next;
	};

	//the top of the list of registered bodiesa

	BodyRegistration *firstBody;



	//the resolver for a set of contacts

	ContactResolve resolver;


	//Struct to hold one contact generator in a linked list

	struct ContactGenRegistration
	{
		ContactGen *gen;
		ContactGenRegistration *next;
	};

	// The top of the list of contact generators
	
	ContactGenRegistration *firstContactGen;

	
	//the array of cotnacts
	Contact *contacts;


	//maximum num of contacts

	unsigned m_wMaxContacts;

	
public:

    /* Added for Physics manager as storage - didn't take do different
	typedef std::vector<BodyRegistration*> BodyRegs;
    typedef std::vector<ContactGenRegistration*> ConGens;
	*/
	//create a new physics world simulator

	World(unsigned m_wMaxContacts, unsigned wIterations=0);

    World(); // creates world and returns pointer

	//I am Zul, destroyer of worlds
	~World();


	//calls the contact generators to report contacts 

	unsigned generateContacts();


	//run the laws of physics as we defineded

	void runPhysics(double dElapsedFrameTime);


	//Initiales the world for a frame of the simulation. why, because we can

	void startFrame();

};



//World Wrapper class.. No, I am not talking about some def rhymes to a killer beat, 
//but an interface to let other cores chill with this homey.

/*
class WorldWrapper
{

	//Velocity of the object

	Vector3D  m_v3Velocity;

	//Position of the object

	Vector3D m_v3Position;

	//ID of the body that is generated by the main core

	int m_iBodyID;

	//boolean to state if a collision occurred

	bool m_bCollisionOccurred;



public:

	//getter to obtain information needed from other cores
	void getDataFromCore (
							Vector3D velocity,
							Vector3D position,
							int bodyID);




	/* finally something to send back the results of the physics
	simulation*//*

	unsigned sendResultsToCore();

}
*/

}
#endif